<?php

//@Formatter:off
/**
 * A simple reference copied from the PHP documentation.
 *     1    E_ERROR                Fatal run-time errors. Errors that cannot be recovered from. Execution of the script
 *                                 is halted.
 *     2    E_WARNING              Run-time warnings (non-fatal errors). Execution of the script is not halted.
 *     4    E_PARSE                Compile-time parse errors. Parse errors should only be generated by the parser.
 *     8    E_NOTICE               Run-time notices. The script found something that might be an error, but could also
 *                                 happen when running a script normally.
 *    16    E_CORE_ERROR           Fatal errors at PHP startup. This is like E_ERROR, except it is generated by the
 *                                 core of PHP.
 *    32    E_CORE_WARNING         Non-fatal errors at PHP startup. This is like E_WARNING, except it is generated by
 *                                 the core of PHP.
 *    64    E_COMPILE_ERROR        Fatal compile-time errors. This is like E_ERROR, except it is generated by by the
 *                                 Zend Scripting Engine.
 *   128    E_COMPILE_WARNING      Non-fatal compile-time errors. This is like E_WARNING, except it is generated by by
 *                                 the Zend Scripting Engine.
 *   256    E_USER_ERROR           Fatal user-generated error. This is like E_ERROR, except it is generated in PHP code
 *                                 by using the PHP function trigger_error().
 *   512    E_USER_WARNING         Non-fatal user-generated warning. This is like E_WARNING, except it is generated in
 *                                 PHP code by using the PHP function trigger_error().
 *  1024    E_USER_NOTICE          User-generated notice. This is like E_NOTICE, except it is generated in PHP code by
 *                                 using the PHP function trigger_error().
 *  2048    E_STRICT               Enable to have PHP suggest changes to your code which will ensure the best
 *                                 interoperability and forward compatibility of your code. (Since PHP 5 but not
 *                                 included in E_ALL until PHP 5.4)
 *  4096    E_RECOVERABLE_ERROR    Catchable fatal error. Indicates that a probably dangerous error occurred, but did
 *                                 not leave the Engine in an unstable state. If the error is not caught by a user
 *                                 defined handle, the application aborts as it was an E_ERROR. (Since PHP 5.2)
 *  8192    E_DEPRECATED           Run-time notices. Enable this to receive warnings about code that will not work in
 *                                 future versions. (Since PHP 5.3)
 * 16384    E_USER_DEPRECATED      User-generated warning message. This is like E_DEPRECATED, except it is generated in
 *                                 PHP code by using the PHP function trigger_error(). (Since PHP 5.3)
 */
//@Formatter:on

/**
 * Class Ando_ErrorFactory
 */
class Ando_ErrorFactory
{
    // -----------------------------------------------------------------------------------------------START CLASS PUBLIC

    const NO_ERROR = null;

    public static
    function instance()
    {
        if ( is_null(self::$instance) ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public static
    function to_str( $error )
    {
        return isset(self::$int2str[$error])
                ? self::$int2str[$error]
                : self::NO_ERROR;  // self::NO_ERROR == '', (string) self::NO_ERROR === ''
    }

    public static
    function to_int( $error )
    {
        return isset(self::$str2int[$error])
                ? self::$str2int[$error]
                : self::NO_ERROR;  // self::NO_ERROR == 0, (int) self::NO_ERROR === 0
    }

    /**
     * @link https://github.com/php/php-src/blob/fc33f52d8c25997dd0711de3e07d0dc260a18c11/main/main.c#L1083
     *
     * @param $type
     *
     * @return string
     */
    public static
    function error_type( $type )
    {
        switch ($type) {
            case E_ERROR:
            case E_CORE_ERROR:
            case E_COMPILE_ERROR:
            case E_USER_ERROR:
                $result = "Fatal error";
                break;
            case E_RECOVERABLE_ERROR:
                $result = "Catchable fatal error";
                break;
            case E_WARNING:
            case E_CORE_WARNING:
            case E_COMPILE_WARNING:
            case E_USER_WARNING:
                $result = "Warning";
                break;
            case E_PARSE:
                $result = "Parse error";
                break;
            case E_NOTICE:
            case E_USER_NOTICE:
                $result = "Notice";
                break;
            case E_STRICT:
                $result = "Strict Standards";
                break;
            case E_DEPRECATED:
            case E_USER_DEPRECATED:
                $result = "Deprecated";
                break;
            default:
                $result = "Unknown error";
                break;
        }
        return $result;
    }

    public static
    function all_errors_mask()
    {
        return self::instance()->all_errors_mask;
    }

    /**
     * @link https://github.com/php/php-src/blob/fc33f52d8c25997dd0711de3e07d0dc260a18c11/Zend/zend.c#L1078
     *
     * @return int
     */
    public static
    function shutdown_errors_mask()
    {
        return self::instance()
                   ->shutdown_errors_mask();
    }

    public static
    function non_shutdown_errors_mask()
    {
        return self::instance()
                   ->non_shutdown_errors_mask();
    }

    public static
    function register_shutdown_error_visualizer()
    {
        register_shutdown_function(array('Ando_ErrorFactory', 'shutdown_error'));
    }

    public static
    function register_non_shutdown_error_visualizer()
    {
        set_error_handler(array('Ando_ErrorFactory', 'non_shutdown_error'));
    }

    // -----------------------------------------------------------------------------------------------------------------

    public static
    function shutdown_error()
    {
        static $count = 0;
        $count += 1;
        if ( $count > 1 ) {
            return;
        }

        $error = error_get_last();
        $level = is_array($error) && isset($error['type']) && is_numeric($error['type'])
                ? (int) $error['type']
                : 0;
        self::see_error(__FUNCTION__, $level, $error);
        // no backtrace available here...
    }

    public static
    function non_shutdown_error( $level, $message, $file, $line, $context )
    {
        $error = array(
                'type'    => $level,
                'message' => $message,
                'file'    => $file,
                'line'    => $line,
                'context' => $context,
        );
        self::see_error(__FUNCTION__, $level, $error);
        debug_print_backtrace();
        return true;  // True means no default error processing is needed.
    }

    // -------------------------------------------------------------------------------------------------END CLASS PUBLIC

    // --------------------------------------------------------------------------------------------START INSTANCE PUBLIC

    public static
    function E_ERROR()
    {
        self::instance()
            ->E_ERROR_by_calling_an_undefined_function();
    }

    public static
    function E_WARNING()
    {
        self::instance()
            ->E_WARNING_by_calling_a_function_with_less_arguments();
    }

    public static
    function E_PARSE()
    {
        self::instance()
            ->E_PARSE_by_not_using_a_semicolon();
    }

    public static
    function E_NOTICE()
    {
        self::instance()
            ->E_NOTICE_by_using_an_undefined_constant();
    }

    public static
    function E_CORE_ERROR()
    {
        self::instance()
            ->E_CORE_ERROR_by_declaring_a_class_directly_implementing_Traversable();
    }

    /**
     * By looking at the PHP source files, I discovered that, unlike E_CORE_ERROR, E_CORE_WARNING is triggered only
     * during low level operations, like loading modules during startup, or handling deactivation of signal handlers
     * during shutdown (5.4+). Given that there is no way to interfere with startup from userland, and given that,
     * as much as I can currently understand from the sources, there is neither a way to do it during shutdown because
     * userland shutdown handlers get executed before zend_signal_deactivate, I'm giving up on this, for now.
     *
     * @link http://lxr.php.net/s?refs=zend_signal_deactivate&project=PHP_5_4
     *
     * For the above reasons this method is not public.
     */
    protected static
    function E_CORE_WARNING()
    {
        self::instance()
            ->no_way_to_trigger_E_CORE_WARNING_from_userland_yet();
    }

    public static
    function E_COMPILE_ERROR()
    {
        self::instance()
            ->E_COMPILE_ERROR_by_declaring_a_class_called_self();
    }

    public static
    function E_COMPILE_WARNING()
    {
        self::instance()
            ->E_COMPILE_WARNING_by_not_closing_a_multiline_comment();
    }

    public static
    function E_USER_ERROR()
    {
        self::instance()
            ->E_USER_ERROR_by_calling_trigger_error_with_type_e_user_error();
    }

    public static
    function E_USER_WARNING()
    {
        self::instance()
            ->E_USER_WARNING_by_calling_trigger_error_with_type_e_user_warning();
    }

    public static
    function E_USER_NOTICE()
    {
        self::instance()
            ->E_USER_NOTICE_by_calling_trigger_error_with_type_e_user_notice();
    }

    public static
    function E_STRICT()
    {
        self::instance()
            ->E_STRICT_by_accessing_static_property_as_non_static();
    }

    public static
    function E_RECOVERABLE_ERROR()
    {
        self::instance()
            ->E_RECOVERABLE_ERROR_by_converting_to_string_an_object_of_a_class_without__to_string();
    }

    public static
    function E_DEPRECATED()
    {
        self::instance()
            ->E_DEPRECATED_by_calling_call_user_method();
    }

    public static
    function E_USER_DEPRECATED()
    {
        self::instance()
            ->E_USER_DEPRECATED_by_calling_trigger_error_with_type_e_user_deprecated();
    }

    // ----------------------------------------------------------------------------------------------END INSTANCE PUBLIC

    // --------------------------------------------------------------------------------------------START CLASS PROTECTED

    protected static $int2str = array(
            0                   => '',
            E_ERROR             => 'E_ERROR',
            E_WARNING           => 'E_WARNING',
            E_PARSE             => 'E_PARSE',
            E_NOTICE            => 'E_NOTICE',
            E_CORE_ERROR        => 'E_CORE_ERROR',
            E_CORE_WARNING      => 'E_CORE_WARNING',
            E_COMPILE_ERROR     => 'E_COMPILE_ERROR',
            E_COMPILE_WARNING   => 'E_COMPILE_WARNING',
            E_USER_ERROR        => 'E_USER_ERROR',
            E_USER_WARNING      => 'E_USER_WARNING',
            E_USER_NOTICE       => 'E_USER_NOTICE',
            E_STRICT            => 'E_STRICT',
            E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR',
            E_DEPRECATED        => 'E_DEPRECATED',
            E_USER_DEPRECATED   => 'E_USER_DEPRECATED',
    );

    protected static $str2int = array(
            ''                    => 0,
            'E_ERROR'             => E_ERROR,
            'E_WARNING'           => E_WARNING,
            'E_PARSE'             => E_PARSE,
            'E_NOTICE'            => E_NOTICE,
            'E_CORE_ERROR'        => E_CORE_ERROR,
            'E_CORE_WARNING'      => E_CORE_WARNING,
            'E_COMPILE_ERROR'     => E_COMPILE_ERROR,
            'E_COMPILE_WARNING'   => E_COMPILE_WARNING,
            'E_USER_ERROR'        => E_USER_ERROR,
            'E_USER_WARNING'      => E_USER_WARNING,
            'E_USER_NOTICE'       => E_USER_NOTICE,
            'E_STRICT'            => E_STRICT,
            'E_RECOVERABLE_ERROR' => E_RECOVERABLE_ERROR,
            'E_DEPRECATED'        => E_DEPRECATED,
            'E_USER_DEPRECATED'   => E_USER_DEPRECATED,
    );

    protected static
    function see_error( $handler, $level, $error )
    {
        $name = Ando_ErrorFactory::to_str($level);
        if ( empty($name) ) {
            $name = '(none)';
        }
        $type = Ando_ErrorFactory::error_type($level);
        echo "\n$handler: $name ($type)\n";
        if ( '(none)' != $name ) {
            echo "\nerror = ", print_r($error, true), "\n";
        }
    }

    // ----------------------------------------------------------------------------------------------END CLASS PROTECTED

    // -----------------------------------------------------------------------------------------START INSTANCE PROTECTED

    protected static $instance;

    protected $all_errors_mask;
    protected $shutdown_errors_mask;
    protected $non_shutdown_errors_mask;

    protected
    function __construct()
    {
        $this->all_errors_mask          = $this->get_all_errors_mask();
        $this->shutdown_errors_mask     = $this->get_shutdown_errors_mask();
        $this->non_shutdown_errors_mask = $this->all_errors_mask & ~$this->shutdown_errors_mask;
    }

    protected
    function get_all_errors_mask()
    {
        $errors = array_values(self::$str2int);
        $result = 0;
        foreach ($errors as $error) {
            $result = $result | $error;
        }
        return $result;
    }

    /**
     * @link https://github.com/php/php-src/blob/fc33f52d8c25997dd0711de3e07d0dc260a18c11/Zend/zend.c#L1078
     *
     * @return int
     */
    protected
    function get_shutdown_errors_mask()
    {
        $result = E_ERROR | E_PARSE | E_CORE_ERROR | E_CORE_WARNING | E_COMPILE_ERROR | E_COMPILE_WARNING;
        return $result;
    }

    // -------------------------------------------------------------------------------------------END INSTANCE PROTECTED

    //--------------------------------------------------------------------------------------------START INSTANCE PRIVATE

    private
    function E_ERROR_by_calling_an_undefined_function()
    {
        $function = 'undefined_function_' . md5(time());
        $function();
    }

    private
    function E_WARNING_by_calling_a_function_with_less_arguments()
    {
        $code = 'function oops($a){} oops();';
        eval($code);
    }

    private
    function E_NOTICE_by_using_an_undefined_constant()
    {
        $code = 'oops;';
        eval($code);
    }

    private
    function E_PARSE_by_not_using_a_semicolon()
    {
        $code = "echo 'oops'";
        eval($code);
    }

    private
    function E_CORE_ERROR_by_declaring_a_class_directly_implementing_Traversable()
    {
        $code = 'class Oops implements Traversable {}';
        eval($code);
    }

    private
    function no_way_to_trigger_E_CORE_WARNING_from_userland_yet()
    {
        // TODO find a way to trigger E_CORE_WARNING from userland

        // You can play with this code if you like, but it doesn't really work.
        // In fact, it only works inside the CLI created by exec "php...".

        $filename = tempnam(sys_get_temp_dir(), 'no_extension_ini_');
        file_put_contents($filename, 'extension=no_extension');
        $code = "php -c $filename xxx";
        exec($code, $output, $return);
    }

    private
    function E_COMPILE_ERROR_by_declaring_a_class_called_self()
    {
        $code = 'class self {}';
        eval($code);
    }

    private
    function E_COMPILE_WARNING_by_not_closing_a_multiline_comment()
    {
        $code = '/* oops';
        eval($code);
    }

    private
    function E_USER_ERROR_by_calling_trigger_error_with_type_e_user_error()
    {
        trigger_error('oops', E_USER_ERROR);
    }

    private
    function E_USER_WARNING_by_calling_trigger_error_with_type_e_user_warning()
    {
        trigger_error('oops', E_USER_WARNING);
    }

    private
    function E_USER_NOTICE_by_calling_trigger_error_with_type_e_user_notice()
    {
        trigger_error('oops', E_USER_NOTICE);
    }

    private
    function E_STRICT_by_accessing_static_property_as_non_static()
    {
        $code = '
        class E_STRICT_Parent {
            function oops($a = array()) {}
        }
        class E_STRICT_Child extends E_STRICT_Parent {
            function oops() {}
        }';
        eval($code);
    }

    private
    function E_RECOVERABLE_ERROR_by_converting_to_string_an_object_of_a_class_without__to_string()
    {
        $code = 'echo new stdClass();';
        eval($code);
    }

    private
    function E_DEPRECATED_by_calling_call_user_method()
    {
        $code = 'class A {public function oops(){}} $a = new A(); call_user_method("oops", $a);';
        eval($code);
    }

    private
    function E_USER_DEPRECATED_by_calling_trigger_error_with_type_e_user_deprecated()
    {
        trigger_error('oops', E_USER_DEPRECATED);
    }

    //----------------------------------------------------------------------------------------------END INSTANCE PRIVATE
}
